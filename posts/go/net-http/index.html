<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Reading the Go Standard Library - net/http | Michael Thornton</title>
<meta name=keywords content="go,go-stdlib,misc">
<meta name=description content="A piece of advice I often see when learning a new language is to read the standard library. So I&rsquo;m taking a tour through go&rsquo;s stdlib in order to get a more comprehensive understanding of the library.
I&rsquo;ve always liked the site Learn X in Y Minutes, and decided as I went through this to write out functions and code in a similar manner. The blog post has split out the comments into Markdown, but if you just wish to see the code, you can do so on github.">
<meta name=author content="Michael Thornton">
<link rel=canonical href=https://thorntonmc.github.io/posts/go/net-http/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://thorntonmc.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://thorntonmc.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://thorntonmc.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://thorntonmc.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://thorntonmc.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<link rel=alternate hreflang=en href=https://thorntonmc.github.io/posts/go/net-http/>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript><meta property="og:title" content="Reading the Go Standard Library - net/http">
<meta property="og:description" content="A piece of advice I often see when learning a new language is to read the standard library. So I&rsquo;m taking a tour through go&rsquo;s stdlib in order to get a more comprehensive understanding of the library.
I&rsquo;ve always liked the site Learn X in Y Minutes, and decided as I went through this to write out functions and code in a similar manner. The blog post has split out the comments into Markdown, but if you just wish to see the code, you can do so on github.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://thorntonmc.github.io/posts/go/net-http/"><meta property="og:image" content="https://thorntonmc.github.io/papermod-cover.png"><meta property="article:section" content="posts">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://thorntonmc.github.io/papermod-cover.png">
<meta name=twitter:title content="Reading the Go Standard Library - net/http">
<meta name=twitter:description content="A piece of advice I often see when learning a new language is to read the standard library. So I&rsquo;m taking a tour through go&rsquo;s stdlib in order to get a more comprehensive understanding of the library.
I&rsquo;ve always liked the site Learn X in Y Minutes, and decided as I went through this to write out functions and code in a similar manner. The blog post has split out the comments into Markdown, but if you just wish to see the code, you can do so on github.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://thorntonmc.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Reading the Go Standard Library - net/http","item":"https://thorntonmc.github.io/posts/go/net-http/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reading the Go Standard Library - net/http","name":"Reading the Go Standard Library - net\/http","description":"A piece of advice I often see when learning a new language is to read the standard library. So I\u0026rsquo;m taking a tour through go\u0026rsquo;s stdlib in order to get a more comprehensive understanding of the library.\nI\u0026rsquo;ve always liked the site Learn X in Y Minutes, and decided as I went through this to write out functions and code in a similar manner. The blog post has split out the comments into Markdown, but if you just wish to see the code, you can do so on github.","keywords":["go","go-stdlib","misc"],"articleBody":"A piece of advice I often see when learning a new language is to read the standard library. So Iâ€™m taking a tour through goâ€™s stdlib in order to get a more comprehensive understanding of the library.\nIâ€™ve always liked the site Learn X in Y Minutes, and decided as I went through this to write out functions and code in a similar manner. The blog post has split out the comments into Markdown, but if you just wish to see the code, you can do so on github.\nMuch of this is heavily curated and toured by Jon Bodner via his book Learning Go.\nGetting Started The net/http reads absolutely beautifully, and the introduction is no different:\n Package http provides HTTP client and server implementations.\n Perfect! Lets dive in by importing some necessary functions from the stdlib, as well as a third party package alice\n// main.go package main import ( \"context\" \"encoding/json\" \"fmt\" \"log\" \"net/http\" \"time\" \"github.com/justinas/alice\" ) The Client The client makes HTTP requests, and receives HTTP responses. Letâ€™s take a look at the client definition:\ntype Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time.Duration } There is a default client instance included, providing an empty \u0026http.Client{}, but you should always use your own, as it has no timeout.\nvar dontUseDefault = http.DefaultClient Once youâ€™ve created your http.Client, you donâ€™t need another one. Itâ€™s designed to properly handle simultaneous requests.\nfunc newClient() *http.Client { client := \u0026http.Client{ Timeout: 30 * time.Second, } return client } When you want to make a request, you create a new *http.Request instance with the http.NewRequestWithContext function\nfunc newReq() *http.Request { req, err := http.NewRequestWithContext(context.Background(), http.MethodGet, \"https://jsonplaceholder.typicode.com/todos/1\", nil) if err != nil { panic(err) } return req } Once you have an *http.Request instance, you can set any headers via the Headers() method of the instance. Once youâ€™re done, you can use the Do() method on the *http.Client with your http.Request which returns an http.Response\nfunc makeReq() *http.Response { c := newClient() req := newReq() req.Header.Add(\"X-My-Client\", \"Learning Go\") resp, err := c.Do(req) if err != nil { panic(err) } return resp } The real work is being done in http.Client.Do() - while there are methods included in the http.Client interface such as Get and Post, those force the usage of http.NewRequest, hindering your ability to pass a context.Context via http.NewRequestWithContext.\nThe *http.Response has several fields with information on the request:\n The status code The text response of the status code The response headers.  The headers type is a map[string][]string with methods Get() and Set() to respectively get and set HTTP headers.\nfunc handleResponse(r *http.Response) { code := r.StatusCode // e.g. 200 \tcodeText := r.Status // e.g. \"200 OK\" \theaders := r.Header contentType := headers.Get(\"Content-Type\") fmt.Printf(\"%d\\n%s\\n%s\", code, codeText, contentType) } Response bodies can be used json.Decoder to process REST API responses\nfunc parseJson(r *http.Response) { // the response body is an io.ReadCloser, which means it can be used to parse json \tbody := r.Body var data struct { UserID int `json:\"userId\"` ID int `json:\"id\"` Title string `json:\"title\"` Complete bool `json:\"completed\"` } err := json.NewDecoder(body).Decode(\u0026data) if err != nil { panic(err) } } The Server The HTTP server is built around the http.Server and the http.Handler interfaces. http.Server listens for HTTP requests. Requests to the server are handled by implementations of http.Handler, which have a single method ServeHTTP\nSince http.Handlers are so important, lets have a look at the interface definition\ntype Handler interface { ServeHTTP(ResponseWriter, *Request) } ServeHTTP takes two arguments - weâ€™ve already looked at http.Request, so lets take a look at http.ResponseWriter\ntype ResponseWriter interface { Header() Header Write([]byte) (int, error) WriteHeader(statusCode int) } Lets jump in define our own handler to explore what these methods do.\ntype NewHandler struct{} func (n NewHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { // the methods in http.ResponseWriter must be called in a certain order \t// the first, Header(), gives you an instnace of http.Header so you can set \t// any headers you need. \t// If you don't need it, don't call it  // Next, call WriteHeader() with the HTTP status code for your response \tw.WriteHeader(http.StatusAccepted) // if you are sending a 200, you can skip it  // Write() sets the body for the response \tw.Write([]byte(\"Hello, world!\\n\")) } Now that we have our server, we can make our handler\nfunc newServer() http.Server { s := http.Server{ Addr: \":8000\", // TCP address to listen. host:port - if not provided, listen on all hosts on port 80 \tReadTimeout: 30 * time.Second, // Time to wait to read request headers \tWriteTimeout: 30 * time.Second, // Time to wait for the write of the response \tIdleTimeout: 120 * time.Second, // Time to wait for the next request when keep-alives are enabled \tHandler: NewHandler{}, // We invoke our handler when we get a request to our server \t} return s } The ListenAndServeMethod starts the the HTTP server\nfunc listen(s http.Server) { err := s.ListenAndServe() if err != nil { panic(err) } } The ServeMux The main problem with our server is that it only handles one path, thankfully *http.ServeMux meets the http.Handler interface, and also serves as a router - sending the requests to the correct http.Handler instance, Servemux instances are the most common way of implementing multiple handlers and are critical to any REST API or HTTP server.\nYou can look at the details of how http.ServeMux does this in its ServeHTTP method and its [Handler] method https://cs.opensource.google/go/go/+/refs/tags/go1.17.6:src/net/http/server.go;l=2361 but, essentially, http.ServeMux implements ServeHTTP(w http.ResponseWriter, r *http.Request), satisfying the http.Handler interface, so it can be passed in as a Handler to http.Server. Itâ€™s ServeHTTP implementation calls the Handler, which parses the path and returns the http.Handler used for the request, and then calls that handlers ServeHTTP method.\n// That sounded a bit confusing, so let's test this out func newServeMux() { m := http.NewServeMux() // creates a blank *http.ServeMux  // create two handlers, an alive and ready path \tm.HandleFunc(\"/alive\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"ok!\\n\")) }) m.HandleFunc(\"ready\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"always\\n\")) }) s := http.Server{ Addr: \":8000\", ReadTimeout: 30 * time.Second, WriteTimeout: 30 * time.Second, IdleTimeout: 120 * time.Second, Handler: m, // Our handler now handles two requests, /alive and /ready \t} s.ListenAndServe() } http.ServeMux instances, since they themselves route requests to http.Handler instances, and since http.ServeMux is itself an instance of a http.Handler interface, an http.ServeMux can handle other http.ServeMux instances. This lets us route nested paths:\nfunc parentChildMux() { user := http.NewServeMux() user.HandleFunc(\"/fetch\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"This is a user!\")) }) record := http.NewServeMux() record.HandleFunc(\"/fetch\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"This is a record!\")) }) mux := http.NewServeMux() // mux will handle both the user and record path. \t// http.StripPrefix removes the part of the path that's already been processed, \t// as the previous handles don't expect the first path \tmux.Handle(\"/user/\", http.StripPrefix(\"/user\", user)) mux.Handle(\"/record\", http.StripPrefix(\"/record\", record)) } A small aside, the HandlerFunc In previous examples, you saw implementations of a http.ServeMux that served functions directly, like this:\nfunc handlerFunc() { m := http.NewServeMux() m.HandleFunc(\"/path\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello, world!\")) }) The http.HandlerFunc is a function that is also a http.Handler. In this case, I think the type definition is more useful then a description:\n// The HandlerFunc type is an adapter to allow the use of // ordinary functions as HTTP handlers. If f is a function // with the appropriate signature, HandlerFunc(f) is a // Handler that calls f. type HandlerFunc func(ResponseWriter, *Request) // ServeHTTP calls f(w, r). func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } Now look at the definition of http.ServeMux.HandleFunc\n// HandleFunc registers the handler function for the given pattern. func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(\"http: nil handler\") } mux.Handle(pattern, HandlerFunc(handler)) } Itâ€™s more clear whatâ€™s happening having looked at these two definitions. http.ServeMux.HandleFunc takes a path, and a func(w http.ResponseWriter, r *http.Request) and typecasts the function to a HandlerFunc. Since HandlerFunc implements ServeHTTP, itâ€™s a valid http.Handler interface, and can be used in a call to mux.Handle\nOne last pitfall The http library offers functions that work with the package instance of *http.ServeMux, declared as:\nvar dontUseDefaultMux = http.DefaultServeMux These functions are http.ListenAndServe, http.HandleFunc, and http.ListenAndServeTLS. http.ListenAndServe and http.ListenAndServeTLS both serve with the default http server, which as mentioned does not contain properties such as timeouts.\nfunc dontUselistenAndServeDefault() { err := http.ListenAndServe(\":80\", nil) if err != nil { panic(err) } err = http.ListenAndServeTLS(\":80\", \"\", \"\", nil) } Using these methods can allow third party packages that have added additional handlers to http.DefaultServeMux to inject vulnerabilities\nMiddleware There is no middleware type in go, just a pattern involving http.Handler instances. Here is our example scenario:\nWe want to implement a path /hello which returns Hello, world!. This sounds simple enough, we simply need a http.ServeMux with the path /hello and a handler that writes out our message. However, we want an additional piece of logic to run before responding to our request:\n We want a check to make sure the user has the secret password in header X-Secret-Password before hitting our /hello handler We want a timer that logs the length of time it takes to read and respond to the request.  We can define our two middleware functions like this:\nRequestTimer takes a http.Handler variable h, and returns in itself a http.Handler. What is this handler? It starts a timer, then runs h, our original handler via h.ServeHTTP, and then logs the length of time it took to complete the function.\nfunc RequestTimer(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { start := time.Now() h.ServeHTTP(w, r) end := time.Now() log.Printf(\"request time for %ss: %v\", r.URL.Path, end.Sub(start)) }) } TerribleSecurityProvider is slightly more complicated. It takes a password string and returns a function - but what does that function do? That function takes a http.Handler and returns a http.Handler, which reads our X-Secret-Password header, and checks to see if its equal to the password when TerribleSecurityProvider was initially called. If the values, match, it runs ServeHTTP on the handler that was passed in.\nvar securityMsg = []byte(\"You didn't give the secret password\\n\") func TerribleSecurityProvider(password string) func(http.Handler) http.Handler { return func(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { if r.Header.Get(\"X-Secret-Password\") != password { w.WriteHeader(http.StatusUnauthorized) w.Write(securityMsg) return } h.ServeHTTP(w, r) }) } } In a nutshell, hereâ€™s how we use ts\nts := TerribleSecurityProvider(\"password\") handler := ts(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello, world\\n\")) })) Now for the implementation! Our mux handles the /hello path with TerribleSecurityProvider, instantiated as ts. As ts is itself a function that takes a handler, we can then pass in RequestTimer to it.\n// If ts passes its security check, it runs h.ServeHTTP, in this case RequestTimer. // If not, it returns, ending the request and breaking the chain. // // If it passes, it calls RequestTimer which itself takes a handler that writes \"Hello, World\" // RequestTimer starts timing the request, and then runs h.ServeHTTP, ultimately serving \"Hello, world\\n\" // on path /hello func muxWithMiddleware() { ts := TerribleSecurityProvider(\"PASSWORD\") mux := http.NewServeMux() mux.Handle(\"/hello\", ts(RequestTimer( http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello, world!\\n\")) })))) } Third party packages: Perhaps itâ€™s just me, but chaining middleware can be a confusing pattern. Alice makes chaining middleware as simple as:\nfunc helloWorldHandler(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"hello, world!\")) } func timeoutHandler(h http.Handler) http.Handler { return http.TimeoutHandler(h, 1*time.Second, \"timed out\") } func aliceWithMiddleWare() { ts := TerribleSecurityProvider(\"PASSWORD\") handler := http.HandlerFunc(helloWorldHandler) a := alice.New(ts, timeoutHandler).Then(handler) s := http.Server{ Addr: \":8000\", ReadTimeout: 30 * time.Second, WriteTimeout: 30 * time.Second, IdleTimeout: 120 * time.Second, Handler: a, } s.ListenAndServe() } Gorilla is too big to cover here but in a nutshell it has a mux package which allows easy use of creating dynamic paths such as /user/{user_id}/name\nWrapping Up Honestly, reading the go stdlib is an incredibly fun, and informative process. Next stop, io\n","wordCount":"1971","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Michael Thornton"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://thorntonmc.github.io/posts/go/net-http/"},"publisher":{"@type":"Organization","name":"Michael Thornton","logo":{"@type":"ImageObject","url":"https://thorntonmc.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://thorntonmc.github.io accesskey=h title="Michael Thornton (Alt + H)">Michael Thornton</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=https://thorntonmc.github.io/tr/ title=Turkish aria-label=:tr:>ðŸ‡¹ðŸ‡·</a>
</li>
</ul>
</span>
</div>
<ul id=menu>
<li>
<a href=https://thorntonmc.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://thorntonmc.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://thorntonmc.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://thorntonmc.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://thorntonmc.github.io>Home</a>&nbsp;Â»&nbsp;<a href=https://thorntonmc.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Reading the Go Standard Library - net/http
</h1>
<div class=post-meta>10 min&nbsp;Â·&nbsp;Michael Thornton&nbsp;|&nbsp;<a href=https://github.com/thorntonmc/thorntonmc.github.io/tree/main/content/posts/go/net-http.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#getting-started aria-label="Getting Started">Getting Started</a></li>
<li>
<a href=#the-client aria-label="The Client">The Client</a></li>
<li>
<a href=#the-server aria-label="The Server">The Server</a><ul>
<ul>
<li>
<a href=#the-servemux aria-label="The ServeMux">The ServeMux</a></li>
<li>
<a href=#a-small-aside-the-handlerfunc aria-label="A small aside, the HandlerFunc">A small aside, the HandlerFunc</a></li>
<li>
<a href=#one-last-pitfall aria-label="One last pitfall">One last pitfall</a></li></ul>
</ul>
</li>
<li>
<a href=#middleware aria-label=Middleware>Middleware</a></li>
<li>
<a href=#third-party-packages aria-label="Third party packages:">Third party packages:</a></li>
<li>
<a href=#wrapping-up aria-label="Wrapping Up">Wrapping Up</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>A piece of advice I <a href=https://patshaughnessy.net/2021/10/23/to-learn-a-new-language-read-its-standard-library>often</a> <a href=https://www.reddit.com/r/golang/comments/evrdds/can_someone_suggest_a_way_to_learn_gos_standard/>see</a> when learning a new language is to read the standard library. So I&rsquo;m taking a tour through <a href=https://pkg.go.dev/std>go&rsquo;s stdlib</a> in order to get a more comprehensive understanding of the library.</p>
<p>I&rsquo;ve always liked the site <a href=https://learnxinyminutes.com>Learn X in Y Minutes</a>, and decided as I went through this to write out functions and code in a similar manner. The blog post has split out the comments into Markdown, but if you just wish to see the code, you can do so on <a href=https://github.com/thorntonmc/go-practice/blob/main/concepts/net/http/main.go>github</a>.</p>
<p>Much of this is heavily curated and toured by <a href=https://medium.com/@jon_43067>Jon Bodner</a> via his book <a href=https://www.oreilly.com/library/view/learning-go/9781492077206/>Learning Go</a>.</p>
<h2 id=getting-started>Getting Started<a hidden class=anchor aria-hidden=true href=#getting-started>#</a></h2>
<p>The <a href=https://pkg.go.dev/net/http>net/http</a> reads absolutely beautifully, and the introduction is no different:</p>
<blockquote>
<p>Package http provides HTTP client and server implementations.</p>
</blockquote>
<p>Perfect! Lets dive in by importing some necessary functions from the stdlib, as well as a third party package <a href=https://github.com/justinas/alice>alice</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// main.go
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;context&#34;</span>
	<span style=color:#e6db74>&#34;encoding/json&#34;</span>
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;log&#34;</span>
	<span style=color:#e6db74>&#34;net/http&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>

	<span style=color:#e6db74>&#34;github.com/justinas/alice&#34;</span>
)
</code></pre></div><h2 id=the-client>The Client<a hidden class=anchor aria-hidden=true href=#the-client>#</a></h2>
<p>The client makes HTTP requests, and receives HTTP responses. Letâ€™s take a look at the client definition:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Client</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Transport</span> <span style=color:#a6e22e>RoundTripper</span>
	<span style=color:#a6e22e>CheckRedirect</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>, <span style=color:#a6e22e>via</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) <span style=color:#66d9ef>error</span>
	<span style=color:#a6e22e>Jar</span> <span style=color:#a6e22e>CookieJar</span>
	<span style=color:#a6e22e>Timeout</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>
}
</code></pre></div><p>There is a <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.6:src/net/http/client.go;l=110">default client instance</a> included, providing an empty <code>&http.Client{}</code>, but you should always use your own, as it has no timeout.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dontUseDefault</span> = <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>DefaultClient</span>
</code></pre></div><p>Once you&rsquo;ve created your http.Client, you don&rsquo;t need another one. It&rsquo;s designed to properly handle simultaneous requests.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newClient</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span> {
	<span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{
		<span style=color:#a6e22e>Timeout</span>: <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>client</span>
}
</code></pre></div><p>When you want to make a request, you create a new *http.Request instance with the http.NewRequestWithContext function</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newReq</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span> {
	<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewRequestWithContext</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodGet</span>, <span style=color:#e6db74>&#34;https://jsonplaceholder.typicode.com/todos/1&#34;</span>, <span style=color:#66d9ef>nil</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#a6e22e>err</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>req</span>
}
</code></pre></div><p>Once you have an <code>*http.Request</code> instance, you can set any headers via the <code>Headers()</code> method of the instance. Once you&rsquo;re done, you can use the <code>Do()</code> method on the <code>*http.Client</code> with your <code>http.Request</code> which returns an <code>http.Response</code></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeReq</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Response</span> {
	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newClient</span>()
	<span style=color:#a6e22e>req</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newReq</span>()
	<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Header</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;X-My-Client&#34;</span>, <span style=color:#e6db74>&#34;Learning Go&#34;</span>)
	<span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>req</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#a6e22e>err</span>)
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resp</span>
}
</code></pre></div><p>The real work is being done in <code>http.Client.Do()</code> - while there are methods included in the <code>http.Client</code> interface such as <code>Get</code> and <code>Post</code>, those force the usage of <code>http.NewRequest</code>, hindering your ability to pass a <code>context.Context</code> via <code>http.NewRequestWithContext</code>.</p>
<p>The <code>*http.Response</code> has several fields with information on the request:</p>
<ol>
<li>The status code</li>
<li>The text response of the status code</li>
<li>The response headers.</li>
</ol>
<p>The <a href=https://pkg.go.dev/net/http#Header><code>headers</code></a> type is a <code>map[string][]string</code> with methods <code>Get()</code> and <code>Set()</code> to respectively get and set HTTP headers.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleResponse</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Response</span>) {
	<span style=color:#a6e22e>code</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>StatusCode</span> <span style=color:#75715e>// e.g. 200
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>codeText</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Status</span> <span style=color:#75715e>// e.g. &#34;200 OK&#34;
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>headers</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Header</span>

	<span style=color:#a6e22e>contentType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>headers</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;Content-Type&#34;</span>) 

	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d\n%s\n%s&#34;</span>, <span style=color:#a6e22e>code</span>, <span style=color:#a6e22e>codeText</span>, <span style=color:#a6e22e>contentType</span>)
}
</code></pre></div><p>Response bodies can be used json.Decoder to process REST API responses</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parseJson</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Response</span>) {
	<span style=color:#75715e>// the response body is an io.ReadCloser, which means it can be used to parse json
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>body</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Body</span>

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#66d9ef>struct</span> {
		<span style=color:#a6e22e>UserID</span>   <span style=color:#66d9ef>int</span>    <span style=color:#e6db74>`json:&#34;userId&#34;`</span>
		<span style=color:#a6e22e>ID</span>       <span style=color:#66d9ef>int</span>    <span style=color:#e6db74>`json:&#34;id&#34;`</span>
		<span style=color:#a6e22e>Title</span>    <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;title&#34;`</span>
		<span style=color:#a6e22e>Complete</span> <span style=color:#66d9ef>bool</span>   <span style=color:#e6db74>`json:&#34;completed&#34;`</span>
	}

	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>NewDecoder</span>(<span style=color:#a6e22e>body</span>).<span style=color:#a6e22e>Decode</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>data</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#a6e22e>err</span>)
	}
}
</code></pre></div><h2 id=the-server>The Server<a hidden class=anchor aria-hidden=true href=#the-server>#</a></h2>
<p>The HTTP server is built around the <code>http.Server</code> and the http.Handler interfaces. <code>http.Server</code> listens for HTTP requests. Requests to the server are handled by implementations of <code>http.Handler</code>, which have a single method ServeHTTP</p>
<p>Since <code>http.Handler</code>s are so important, lets have a look at the <a href="https://pkg.go.dev/net/http?utm_source=gopls#Handler">interface definition</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go> 	<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Handler</span> <span style=color:#66d9ef>interface</span> {
		<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>)
	}
</code></pre></div><p>ServeHTTP takes two arguments - we&rsquo;ve already looked at <code>http.Request</code>, so lets take a look at <a href="https://pkg.go.dev/net/http?utm_source=gopls#ResponseWriter"><code>http.ResponseWriter</code></a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ResponseWriter</span> <span style=color:#66d9ef>interface</span> {
		<span style=color:#a6e22e>Header</span>() <span style=color:#a6e22e>Header</span>
		<span style=color:#a6e22e>Write</span>([]<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>error</span>)
		<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>statusCode</span> <span style=color:#66d9ef>int</span>)
	}
</code></pre></div><p>Lets jump in define our own handler to explore what these methods do.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>NewHandler</span> <span style=color:#66d9ef>struct</span>{}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>n</span> <span style=color:#a6e22e>NewHandler</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
	<span style=color:#75715e>// the methods in http.ResponseWriter must be called in a certain order
</span><span style=color:#75715e></span>	<span style=color:#75715e>// the first, Header(), gives you an instnace of http.Header so you can set
</span><span style=color:#75715e></span>	<span style=color:#75715e>// any headers you need.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// If you don&#39;t need it, don&#39;t call it
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// Next, call WriteHeader() with the HTTP status code for your response
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusAccepted</span>) <span style=color:#75715e>// if you are sending a 200, you can skip it
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// Write() sets the body for the response
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;Hello, world!\n&#34;</span>))
}
</code></pre></div><p>Now that we have our server, we can make our handler</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newServer</span>() <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span> {
	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span>{
		<span style=color:#a6e22e>Addr</span>:         <span style=color:#e6db74>&#34;:8000&#34;</span>,           <span style=color:#75715e>// TCP address to listen. host:port - if not provided, listen on all hosts on port 80
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>ReadTimeout</span>:  <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,  <span style=color:#75715e>// Time to wait to read request headers
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>WriteTimeout</span>: <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,  <span style=color:#75715e>// Time to wait for the write of the response
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>IdleTimeout</span>:  <span style=color:#ae81ff>120</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>, <span style=color:#75715e>// Time to wait for the next request when keep-alives are enabled
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>Handler</span>:      <span style=color:#a6e22e>NewHandler</span>{},      <span style=color:#75715e>// We invoke our handler when we get a request to our server
</span><span style=color:#75715e></span>	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
}
</code></pre></div><p>The <code>ListenAndServeMethod</code> starts the the HTTP server</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>listen</span>(<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span>) {
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ListenAndServe</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#a6e22e>err</span>)
	}
}
</code></pre></div><h4 id=the-servemux>The ServeMux<a hidden class=anchor aria-hidden=true href=#the-servemux>#</a></h4>
<p>The main problem with our server is that it only handles one path, thankfully <code>*http.ServeMux</code> meets the http.Handler interface, and also serves as a router - sending the requests to the correct http.Handler instance, Servemux instances are the most common way of implementing multiple handlers and are critical to any REST API or HTTP server.</p>
<p>You can look at the details of how http.ServeMux does this in its <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.6:src/net/http/server.go;l=2416">ServeHTTP method</a>
and its [Handler] method <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.6:src/net/http/server.go;l=2361">https://cs.opensource.google/go/go/+/refs/tags/go1.17.6:src/net/http/server.go;l=2361</a> but, essentially, http.ServeMux implements <code>ServeHTTP(w http.ResponseWriter, r *http.Request)</code>, satisfying the <code>http.Handler</code> interface, so it can be passed in as a Handler to <code>http.Server</code>. Itâ€™s <code>ServeHTTP</code> implementation calls the Handler, which parses the path and returns the <code>http.Handler</code> used for the request, and then calls that handlers <code>ServeHTTP</code> method.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// That sounded a bit confusing, so let&#39;s test this out
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newServeMux</span>() {
	<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>() <span style=color:#75715e>// creates a blank *http.ServeMux
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// create two handlers, an alive and ready path
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/alive&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
		<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;ok!\n&#34;</span>))
	})
	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;ready&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
		<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;always\n&#34;</span>))
	})

	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span>{
		<span style=color:#a6e22e>Addr</span>:         <span style=color:#e6db74>&#34;:8000&#34;</span>,
		<span style=color:#a6e22e>ReadTimeout</span>:  <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
		<span style=color:#a6e22e>WriteTimeout</span>: <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
		<span style=color:#a6e22e>IdleTimeout</span>:  <span style=color:#ae81ff>120</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
		<span style=color:#a6e22e>Handler</span>:      <span style=color:#a6e22e>m</span>, <span style=color:#75715e>// Our handler now handles two requests, /alive and /ready
</span><span style=color:#75715e></span>	}

	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ListenAndServe</span>()
}
</code></pre></div><p><code>http.ServeMux</code> instances, since they themselves route requests to <code>http.Handler</code> instances, and since <code>http.ServeMux</code> is itself an instance of a <code>http.Handler</code> interface, an <code>http.ServeMux</code> can handle other <code>http.ServeMux instances</code>. This lets us route nested paths:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parentChildMux</span>() {
	<span style=color:#a6e22e>user</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>()
	<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/fetch&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
		<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;This is a user!&#34;</span>))
	})

	<span style=color:#a6e22e>record</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>()
	<span style=color:#a6e22e>record</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/fetch&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
		<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;This is a record!&#34;</span>))
	})

	<span style=color:#a6e22e>mux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>()

	<span style=color:#75715e>// mux will handle both the user and record path.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// http.StripPrefix removes the part of the path that&#39;s already been processed,
</span><span style=color:#75715e></span>	<span style=color:#75715e>// as the previous handles don&#39;t expect the first path
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/user/&#34;</span>, <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StripPrefix</span>(<span style=color:#e6db74>&#34;/user&#34;</span>, <span style=color:#a6e22e>user</span>))
	<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/record&#34;</span>, <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StripPrefix</span>(<span style=color:#e6db74>&#34;/record&#34;</span>, <span style=color:#a6e22e>record</span>))
}
</code></pre></div><h4 id=a-small-aside-the-handlerfunc>A small aside, the HandlerFunc<a hidden class=anchor aria-hidden=true href=#a-small-aside-the-handlerfunc>#</a></h4>
<p>In previous examples, you saw implementations of a <code>http.ServeMux</code> that served functions directly, like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handlerFunc</span>() {
	<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>()
	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/path&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
		<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;Hello, world!&#34;</span>))
	})
</code></pre></div><p>The <code>http.HandlerFunc</code> is a function that is also a <code>http.Handler</code>. In this case, I think the <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.6:src/net/http/server.go;l=2043">type definition</a> is more useful then a description:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// The HandlerFunc type is an adapter to allow the use of
</span><span style=color:#75715e>// ordinary functions as HTTP handlers. If f is a function
</span><span style=color:#75715e>// with the appropriate signature, HandlerFunc(f) is a
</span><span style=color:#75715e>// Handler that calls f.
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>HandlerFunc</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>)

<span style=color:#75715e>// ServeHTTP calls f(w, r).
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span> <span style=color:#a6e22e>HandlerFunc</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) {
	<span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>)
}
</code></pre></div><p>Now look at the <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.6:src/net/http/server.go;drc=refs%2Ftags%2Fgo1.17.6;bpv=0;bpt=1;l=2080">definition</a> of <code>http.ServeMux.HandleFunc</code></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// HandleFunc registers the handler function for the given pattern.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>mux</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ServeMux</span>) <span style=color:#a6e22e>HandleFunc</span>(<span style=color:#a6e22e>pattern</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>handler</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>)) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#e6db74>&#34;http: nil handler&#34;</span>)
	}
	<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#a6e22e>pattern</span>, <span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#a6e22e>handler</span>))
}
</code></pre></div><p>It&rsquo;s more clear what&rsquo;s happening having looked at these two definitions. <code>http.ServeMux.HandleFunc</code> takes a path, and a <code>func(w http.ResponseWriter, r *http.Request)</code> and typecasts the function to a <code>HandlerFunc</code>. Since <code>HandlerFunc</code> implements <code>ServeHTTP</code>, it&rsquo;s a valid <code>http.Handler</code> interface, and can be used in a call to <code>mux.Handle</code></p>
<h4 id=one-last-pitfall>One last pitfall<a hidden class=anchor aria-hidden=true href=#one-last-pitfall>#</a></h4>
<p>The http library offers functions that work with the package instance of <code>*http.ServeMux</code>, declared as:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dontUseDefaultMux</span> = <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>DefaultServeMux</span>
</code></pre></div><p>These functions are <code>http.ListenAndServe</code>, <code>http.HandleFunc</code>, and <code>http.ListenAndServeTLS</code>. <code>http.ListenAndServe</code> and <code>http.ListenAndServeTLS</code> both serve with the default http server, which as mentioned does not contain properties such as timeouts.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dontUselistenAndServeDefault</span>() {
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:80&#34;</span>, <span style=color:#66d9ef>nil</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#a6e22e>err</span>)
	}

	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServeTLS</span>(<span style=color:#e6db74>&#34;:80&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#66d9ef>nil</span>)
}
</code></pre></div><p>Using these methods can allow third party packages that have added additional handlers to <code>http.DefaultServeMux</code> to inject vulnerabilities</p>
<h2 id=middleware>Middleware<a hidden class=anchor aria-hidden=true href=#middleware>#</a></h2>
<p>There is no middleware type in go, just a pattern involving http.Handler instances. Here is our example scenario:</p>
<p>We want to implement a path <code>/hello</code> which returns <code>Hello, world!</code>. This sounds simple enough, we simply need a <code>http.ServeMux</code> with the path <code>/hello</code> and a handler that writes out our message. However, we want an additional piece of logic to run before responding to our request:</p>
<ul>
<li>We want a check to make sure the user has the secret password in header <code>X-Secret-Password</code> before hitting our <code>/hello</code> handler</li>
<li>We want a timer that logs the length of time it takes to read and respond to the request.</li>
</ul>
<p>We can define our two middleware functions like this:</p>
<p><code>RequestTimer</code> takes a <code>http.Handler</code> variable <code>h</code>, and returns in itself a <code>http.Handler</code>. What is this handler? It starts a timer, then runs <code>h</code>, our original handler via <code>h.ServeHTTP</code>, and then logs the length of time it took to complete the function.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>RequestTimer</span>(<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span>) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
		<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
		<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>)
		<span style=color:#a6e22e>end</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;request time for %ss: %v&#34;</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>, <span style=color:#a6e22e>end</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>start</span>))
	})
}
</code></pre></div><p><code>TerribleSecurityProvider</code> is slightly more complicated. It takes a <code>password</code> string and returns a function - but what does that function do? That function takes a <code>http.Handler</code> and returns a <code>http.Handler</code>, which reads our <code>X-Secret-Password</code> header, and checks to see if its equal to the password when <code>TerribleSecurityProvider</code> was initially called. If the values, match, it runs <code>ServeHTTP</code> on the handler that was passed in.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>securityMsg</span> = []byte(<span style=color:#e6db74>&#34;You didn&#39;t give the secret password\n&#34;</span>)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TerribleSecurityProvider</span>(<span style=color:#a6e22e>password</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span>) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span>) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Header</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;X-Secret-Password&#34;</span>) <span style=color:#f92672>!=</span> <span style=color:#a6e22e>password</span> {
				<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusUnauthorized</span>)
				<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>securityMsg</span>)
				<span style=color:#66d9ef>return</span>
			}
			<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>)
		})
	}
}
</code></pre></div><p>In a nutshell, here&rsquo;s how we use <code>ts</code></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ts</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TerribleSecurityProvider</span>(<span style=color:#e6db74>&#34;password&#34;</span>)
<span style=color:#a6e22e>handler</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ts</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;Hello, world\n&#34;</span>))
}))
</code></pre></div><p>Now for the implementation! Our mux handles the <code>/hello</code> path with <code>TerribleSecurityProvider</code>, instantiated as <code>ts</code>. As <code>ts</code> is itself a function that takes a handler, we can then pass in <code>RequestTimer</code> to it.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// If ts passes its security check, it runs h.ServeHTTP, in this case RequestTimer.
</span><span style=color:#75715e>// If not, it returns, ending the request and breaking the chain.
</span><span style=color:#75715e>//
</span><span style=color:#75715e>// If it passes, it calls RequestTimer which itself takes a handler that writes &#34;Hello, World&#34;
</span><span style=color:#75715e>// RequestTimer starts timing the request, and then runs h.ServeHTTP, ultimately serving &#34;Hello, world\n&#34;
</span><span style=color:#75715e>// on path /hello
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>muxWithMiddleware</span>() {
	<span style=color:#a6e22e>ts</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TerribleSecurityProvider</span>(<span style=color:#e6db74>&#34;PASSWORD&#34;</span>)
	<span style=color:#a6e22e>mux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>()

	<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/hello&#34;</span>, <span style=color:#a6e22e>ts</span>(<span style=color:#a6e22e>RequestTimer</span>(
		<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
			<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;Hello, world!\n&#34;</span>))
		}))))
}
</code></pre></div><h2 id=third-party-packages>Third party packages:<a hidden class=anchor aria-hidden=true href=#third-party-packages>#</a></h2>
<p>Perhaps itâ€™s just me, but chaining middleware can be a confusing pattern. <a href=https://justinas.org/alice-painless-middleware-chaining-for-go>Alice</a> makes chaining middleware as simple as:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>helloWorldHandler</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;hello, world!&#34;</span>))
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>timeoutHandler</span>(<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span>) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>TimeoutHandler</span>(<span style=color:#a6e22e>h</span>, <span style=color:#ae81ff>1</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>, <span style=color:#e6db74>&#34;timed out&#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>aliceWithMiddleWare</span>() {
	<span style=color:#a6e22e>ts</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TerribleSecurityProvider</span>(<span style=color:#e6db74>&#34;PASSWORD&#34;</span>)
	<span style=color:#a6e22e>handler</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#a6e22e>helloWorldHandler</span>)

	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>alice</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>ts</span>, <span style=color:#a6e22e>timeoutHandler</span>).<span style=color:#a6e22e>Then</span>(<span style=color:#a6e22e>handler</span>)

	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span>{
		<span style=color:#a6e22e>Addr</span>:         <span style=color:#e6db74>&#34;:8000&#34;</span>,
		<span style=color:#a6e22e>ReadTimeout</span>:  <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
		<span style=color:#a6e22e>WriteTimeout</span>: <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
		<span style=color:#a6e22e>IdleTimeout</span>:  <span style=color:#ae81ff>120</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
		<span style=color:#a6e22e>Handler</span>:      <span style=color:#a6e22e>a</span>,
	}

	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ListenAndServe</span>()
}
</code></pre></div><p><a href=https://github.com/gorilla>Gorilla</a> is too big to cover here but in a nutshell it has a <a href=https://github.com/gorilla/mux>mux package</a> which allows easy use of creating dynamic paths such as <code>/user/{user_id}/name</code></p>
<h2 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2>
<p>Honestly, reading the go stdlib is an incredibly fun, and informative process. Next stop, <a href=https://pkg.go.dev/io><code>io</code></a></p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://thorntonmc.github.io/tags/go/>go</a></li>
<li><a href=https://thorntonmc.github.io/tags/go-stdlib/>go-stdlib</a></li>
<li><a href=https://thorntonmc.github.io/tags/misc/>misc</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://thorntonmc.github.io/posts/sre-challenge/sre-challenge/>
<span class=title>Â« Prev Page</span>
<br>
<span>A Reddit SRE Challenge - Part 1</span>
</a>
<a class=next href=https://thorntonmc.github.io/posts/misc/splitting-out-git-repos/>
<span class=title>Next Page Â»</span>
<br>
<span>Split out a Git Repo and Keep it's Commit History</span>
</a>
</nav>
</footer>
</article>
</main>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>