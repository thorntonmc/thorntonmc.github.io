[{"content":"Configuring a Helm Chart Helm is considered to be the package manager for Kubernetes, and so in addition to terraforming our application, I created a chart for it as well. The first thing to do is to initialize your chart like so:\nhelm create sre-challenge This creates our base chart scaffolding, but before we get started tweaking it - a critical component of helm involves leveraging existing charts, so the first thing to do is find a redis chart.\nmichaelthornton@home:~/sre-challenge/deployments/helm/sre-challenge [main] $ helm search repo redis NAME CHART VERSION\tAPP VERSION\tDESCRIPTION bitnami/redis 15.7.1 6.2.6 Open source, advanced key-value store. It is of... bitnami/redis-cluster\t7.1.0 6.2.6 Open source, advanced key-value store. It is of... We can then add that as a dependency to a chart by updating Chart.yaml\ndependencies: - name: redis version: 15.7.1 repository: https://charts.bitnami.com/bitnami After that, we can run helm dependency update to pull in our redis dependency\nmichaelthornton@work:~/sre-challenge/deployments/helm/sre-challenge [main] $ helm dependency update Hang tight while we grab the latest from your chart repositories... ...Successfully got an update from the \u0026#34;bitnami\u0026#34; chart repository Update Complete. ⎈Happy Helming!⎈ Saving 1 charts Downloading redis from repo https://charts.bitnami.com/bitnami Deleting outdated charts michaelthornton@work:~/sre-challenge/deployments/helm/sre-challenge [main] $ ls charts redis-15.7.1.tgz ","permalink":"https://thorntonmc.github.io/posts/sre-challenge/sre-challenge-helm/","summary":"Configuring a Helm Chart Helm is considered to be the package manager for Kubernetes, and so in addition to terraforming our application, I created a chart for it as well. The first thing to do is to initialize your chart like so:\nhelm create sre-challenge This creates our base chart scaffolding, but before we get started tweaking it - a critical component of helm involves leveraging existing charts, so the first thing to do is find a redis chart.","title":"A Reddit SRE Challenge - Building a Helm Chart"},{"content":"","permalink":"https://thorntonmc.github.io/posts/misc/splitting-out-git-repos/","summary":"","title":"A Reddit SRE Challenge - Part 1"},{"content":"Introduction There was a thread on the devops subreddit going around about a interview challenge for a junior SRE position. Considering I\u0026rsquo;ve been doing more work that might be classified under this role, I figured I\u0026rsquo;d give it a try. Lets take a look at the README.md, I\u0026rsquo;ve reworked it a bit for brevity, you can see the original on github, along with all of the code described in this post:\n   Using Go, write a simple application, http server, which serves 2 endpoints:\n /requests, which increments the hits in in redis and additionally returns hello, world to the caller “/queries” will return the number of hits recorded in redis    Build a helm chart of the http server you wrote. Explain which kind of k8s resource you picked and why? Add liveness and readiness Expose the service port to 3030 Install kind to test you application and install the helm chart\n  Build a github actions file that triggers a build on specific wildcard PR (build) and one merge to master and create tags, which builds your container, run unit tests, and saves to the registry with the correct version.\n   There were originally some other items which I won\u0026rsquo;t be tackling at this time (I won\u0026rsquo;t be terraforming to EKS or GCP, though I did use terraform as my original deployment)\nWriting the HTTP Server Let\u0026rsquo;s get started and write our HTTP server so we can get into the fun stuff, starting with our basic struct:\ntype App struct { listenAddr string mux *http.ServeMux rdb *redis.Client } This is pretty straightforward, our App does three things: it listens on a desired address and port, routes paths via a ServeMux, and gets and sets our redis cache. The rest of this article will be implementing this functionality.\nConfig Options While this is a fairly barebones API, there is some level of configuration we should pass; namely the redis address and password, and the port we should listen on. Let\u0026rsquo;s define our struct:\ntype Config struct { port int redisAddress string redisPassword string } In this example, we\u0026rsquo;ll simply set the value from our enviornment variables, so our init function is quite simple\nfunc NewConfigFromEnv() Config { return newConfigFromEnv() } func newConfigFromEnv() Config { portOverride, ok := os.LookupEnv(\u0026#34;APP_PORT\u0026#34;) if ok { portOverride, err := strconv.Atoi(portOverride) if err != nil { log.Fatalf(\u0026#34;Failed to parse port override\u0026#34;) } port = portOverride } redisAddressOverride, ok := os.LookupEnv(\u0026#34;REDIS_ADDRESS\u0026#34;) if ok { redisAddress = redisAddressOverride } redisPortOverride, ok := os.LookupEnv(\u0026#34;REDIS_PORT\u0026#34;) if ok { log.Printf(\u0026#34;have redisPortOverride %s\u0026#34;, redisPortOverride) redisPortOverride, err := strconv.Atoi(redisPortOverride) if err != nil { log.Fatalf(\u0026#34;Failed to parse redis port override\u0026#34;) } redisPort = redisPortOverride } return Config{ port: port, redisAddress: fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, redisAddress, redisPort), redisPassword: redisPassword, } } Creating the Redis Client Our application needs a redis client so that it can get/set keys upon request, so let\u0026rsquo;s create this in a new file redis.go\nfunc NewRedisClient(addr, password string) *redis.Client { log.Printf(\u0026#34;configuring redis at %s\u0026#34;, addr) rdb := redis.NewClient(\u0026amp;redis.Options{ Addr: addr, Password: password, DB: 0, }) return rdb } We\u0026rsquo;ll also want some functions to get/set our \u0026ldquo;hits\u0026rdquo; key, so let\u0026rsquo;s add them too:\nfunc (a *App) setHits(val string) error { err := a.rdb.Set(context.Background(), \u0026#34;hits\u0026#34;, val, 0).Err() if err != nil { return err } return nil } func (a *App) getHits() (string, error) { hits, err := a.rdb.Get(context.Background(), \u0026#34;hits\u0026#34;).Result() if err != nil { return \u0026#34;\u0026#34;, err } return hits, err } The requirement states that we need to either create the hits key or increment it each call to /requests, so we\u0026rsquo;ll create that logic as well:\nfunc (a *App) updateHits() error { var hits string hits, err := a.getHits() if err == redis.Nil { // key does not exist, so set it to 1 \terr := a.setHits(\u0026#34;1\u0026#34;) if err != nil { return err } return nil } if err != nil { return err } return a.incrementHits(hits) // increment the current value } func (a *App) incrementHits(hits string) error { hitsInt, err := strconv.Atoi(hits) if err != nil { return err } hitsInt += 1 hits = strconv.Itoa(hitsInt) return = a.setHits(hits) } Routing Requests The last thing our application needs a serveMux in order to route our requests. We need to handle two routes /requests and /queries \u0026ndash; since these routes will utilize the redis connection created as a part of our application, we\u0026rsquo;ll make them methods of our app:\nfunc (a *App) handleRequests(w http.ResponseWriter, r *http.Request) { err := a.updateHits() if err != nil { log.Println(err.Error()) w.WriteHeader(http.StatusInternalServerError) w.Write([]byte(err.Error())) return } w.WriteHeader(http.StatusOK) w.Write([]byte(\u0026#34;Hello, World\\n\u0026#34;)) } func (a *App) handleQueries(w http.ResponseWriter, r *http.Request) { hits, err := a.getHits() if err == redis.Nil { w.Write([]byte(\u0026#34;0\\n\u0026#34;)) w.WriteHeader(http.StatusOK) return } if err != nil { w.Write([]byte(err.Error())) w.WriteHeader(http.StatusInternalServerError) return } w.Write([]byte(hits)) w.WriteHeader(http.StatusOK) } Now our app is ready to be used! Let\u0026rsquo;s throw in an init method so that we can easily run it from our calling function, and we also need a simple method to actually start the http server:\n// NewApp returns a new bare application with a webserver configured and ready func NewApp(c Config) *App { return newApp(c) } func newApp(c Config) *App { app := \u0026amp;App{} mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/requests\u0026#34;, app.handleRequests) mux.HandleFunc(\u0026#34;/queries\u0026#34;, app.handleQueries) app.mux = mux app.rdb = NewRedisClient(c.redisAddress, c.redisPassword) app.listenAddr = fmt.Sprintf(\u0026#34;:%d\u0026#34;, port) return app } func (a *App) Serve() { log.Printf(\u0026#34;Listening on %s\u0026#34;, a.listenAddr) log.Fatal(http.ListenAndServe(a.listenAddr, a.mux)) } Excellent! Now our app can be initialized, and the listener can be started simply by importing the package! This is the last missing piece of this puzzle. To run the application from the command line easily, I used the cobra package. The usage readme and user guide are helpful with getting setup, but in a nutshell, cobra creates a main.go in your root directory and also creates cmd/root.go. main.go then imports cmd/root.go which contains all the information around how your program handles flags and commands. Ours is simple, as we can see:\nmain.go\npackage main import ( \u0026#34;github.com/thorntonmc/sre-challenge/cmd\u0026#34; ) func main() { cmd.Execute() } cmd/root.go\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; app \u0026#34;github.com/thorntonmc/sre-challenge/internal\u0026#34; \u0026#34;github.com/spf13/cobra\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) // This file also contains the scaffolding for your cli application, but what\u0026#39;s important is what is in rootCmd var rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;sre-challenge\u0026#34;, Short: \u0026#34;Junior SRE Interview\u0026#34;, Long: \u0026#34;Junior SRE Interview\u0026#34;, Run: func(cmd *cobra.Command, args []string) { c := app.NewConfigFromEnv() a := app.NewApp(c) a.Serve() }, } In a nutshell, cobra will run what\u0026rsquo;s inside rootCmd when the application is run with no parameters, which is what we want as there aren\u0026rsquo;t any flags that are used in this program. The Run function is very simple, we simply initialize our config via the package we wrote earlier, then create a new application via NewApp, and then run our server.\nNow we\u0026rsquo;re ready to test it out! Since we want to keep our a build, tests, and deploys idempotent, lets keep our habits in check by putting our build steps in a Makefile\n./Makefile\n.DEFAULT_GOAL := build # default to the build target MAKEFLAGS= -s . # makefile is silent BUILD_DIR=./build fmt: go fmt ./ build: fmt go build -o $(BUILD_DIR)/sre-challenge.go ./main.go install: fmt build go install clean: rm -rf $(BUILD_DIR) Cool! Now we when we want to build our application we can simply type make build and the binary will be created in ./build/sre-challenge.go \u0026ndash; and since we\u0026rsquo;ve also set build to be our default goal, we can actually just type make to build our application.\nThe install target will also install our binary to $GOPATH/bin\nmichaelthornton@work:~/sre-challenge [main] $ make install michaelthornton@work:~/sre-challenge [main] $ ls $GOPATH/bin cobra cr go-outline gopls sre-challenge So now we can run our app! Let\u0026rsquo;s try it out\nmichaelthornton@work:~/sre-challenge [main] $ sre-challenge 2022/01/11 09:56:45 configuring redis at redis.sre-challenge:6379 2022/01/11 09:56:45 Listening on :8080 This is great! However since we have no redis server installed - the server is basically useless. In our next post, we\u0026rsquo;ll deploy this application and a redis cache to a local kubernetes cluster.\n","permalink":"https://thorntonmc.github.io/posts/sre-challenge/sre-challenge/","summary":"Introduction There was a thread on the devops subreddit going around about a interview challenge for a junior SRE position. Considering I\u0026rsquo;ve been doing more work that might be classified under this role, I figured I\u0026rsquo;d give it a try. Lets take a look at the README.md, I\u0026rsquo;ve reworked it a bit for brevity, you can see the original on github, along with all of the code described in this post:","title":"A Reddit SRE Challenge - Part 1"}]